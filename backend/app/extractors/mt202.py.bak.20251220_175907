# backend/app/extractors/mt202.py
import re
from datetime import datetime
from dateutil import parser as dateparser
import pdfplumber

# Regex de base
BIC_RE = re.compile(r'\b[A-Z]{4}[A-Z]{2}[A-Z0-9]{2}(?:[A-Z0-9]{3})?\b')
MT_RE = re.compile(r'\b(?:MT|FIN)[\s\-_]*(\d{3})\b', re.I)

# map pays CEMAC
CEMAC_MAP = {
    "CM": "CMR", "CMR": "CMR", "CAMEROON": "CMR",
    "GA": "GAB", "GAB": "GAB", "GABON": "GAB",
    "TD": "TCD", "TCD": "TCD", "CHAD": "TCD",
    "CG": "COG", "COG": "COG", "CONGO": "COG",
    "GQ": "GNQ", "GNQ": "GNQ", "EQUATORIAL GUINEA": "GNQ",
    "CF": "CAF", "CAF": "CAF", "CENTRAL AFRICAN REPUBLIC": "CAF"
}

# ---------- utils ----------
def extract_text_from_pdf(path):
    txt = ""
    with pdfplumber.open(str(path)) as pdf:
        for page in pdf.pages:
            txt += "\n" + (page.extract_text() or "")
    return txt

def get_field_block(text, field_label):
    """
    retourne le bloc de texte qui suit Fxx (multiligne) jusqu'au prochain Fyy
    field_label exemple: 'F20' ou 'F32A' ou 'F52A'
    """
    pattern = re.compile(r'(?si)(' + re.escape(field_label) + r'[:\s]*)(.*?)(?=\nF\d{2}[A-Z]?:|\nF\d{2}\b|$)')
    m = pattern.search(text)
    return m.group(2).strip() if m else None

def parse_amount(s):
    if not s:
        return None
    s = s.strip()
    s = re.sub(r'[^\d,.\-]', '', s)  # keep digits, comma, dot, minus
    # Normalize thousands/decimal:
    if s.count(',') and s.count('.'):
        # decide by last separator position
        if s.rfind(',') > s.rfind('.'):
            s = s.replace('.', '').replace(',', '.')
        else:
            s = s.replace(',', '')
    else:
        # only comma => could be decimal or thousands
        if s.count(','):
            idx = s.rfind(',')
            # if 1-2 digits after comma => decimal
            if len(s) - idx - 1 in (1, 2):
                s = s.replace(',', '.')
            else:
                s = s.replace(',', '')
    try:
        return float(s)
    except:
        return None

def parse_date_YYMMDD(s):
    if not s:
        return None
    s = s.strip()
    if re.fullmatch(r'\d{6}', s):
        yy = int(s[:2]); mm = int(s[2:4]); dd = int(s[4:6])
        year = 2000 + yy
        try:
            return datetime(year, mm, dd).date().isoformat()
        except:
            return None
    # try general parse
    try:
        d = dateparser.parse(s, dayfirst=False)
        return d.date().isoformat() if d else None
    except:
        return None

def detect_country_from_text(txt):
    txtu = txt.upper()
    # priority: lines ending with a 2-letter token that matches map
    for line in txtu.splitlines():
        parts = line.strip().split()
        if not parts: continue
        last = parts[-1].strip().strip(',')
        if last in CEMAC_MAP:
            return CEMAC_MAP[last]
    # look for full country names
    for key in CEMAC_MAP:
        if len(key) > 2 and key in txtu:
            return CEMAC_MAP[key]
    # fallback: any two-letter token
    tokens = re.findall(r'\b[A-Z]{2}\b', txtu)
    for t in tokens:
        if t in CEMAC_MAP:
            return CEMAC_MAP[t]
    return None

# ---------- field parsers ----------
def parse_reference(text):
    # handle F20 then F21; return the most likely reference (pattern with slash or digits)
    blk = get_field_block(text, 'F20')
    if blk:
        for ln in blk.splitlines():
            ln = ln.strip()
            if not ln: continue
            # if line looks like a reference (contains digits and /) return it
            if re.search(r'\d+\/\d+|\d{4}\-\d+|[A-Z0-9]+\/[A-Z0-9]+', ln):
                return ln
            # else keep scanning; maybe real reference on next line
        # if none matched inside block, maybe the next line after label contains it:
        lines = [l.strip() for l in blk.splitlines() if l.strip()]
        if len(lines) >= 2:
            # try second line
            return lines[1]
        if lines:
            return lines[0]

    # fallback F21
    blk2 = get_field_block(text, 'F21')
    if blk2:
        for ln in blk2.splitlines():
            ln = ln.strip()
            if ln:
                return ln
    # last try: search for a pattern anywhere (first occurrence of slash reference)
    m = re.search(r'([A-Z0-9\-]{2,30}\/[A-Z0-9\-\/]{1,60})', text)
    if m:
        return m.group(1).strip()
    return None

def parse_f32a(text):
    """Retourne dict: date_reference(YYYY-MM-DD), devise (3letters), montant (float)"""
    blk = get_field_block(text, 'F32A')
    if not blk:
        # fallback: try to gather lines that contain Date:, Currency:, Amount:
        blk = text

    res = {'date_reference': None, 'devise': None, 'montant': None}

    # date search
    m_date = re.search(r'(?i)Date[:\s]*([0-9]{6})', blk)
    if m_date:
        res['date_reference'] = parse_date_YYMMDD(m_date.group(1))
    else:
        # try any 6-digit date in block
        m_date2 = re.search(r'(\d{6})', blk)
        if m_date2:
            res['date_reference'] = parse_date_YYMMDD(m_date2.group(1))

    # currency search: prefer "Currency:" blocks, otherwise three-letter code
    m_cur = re.search(r'(?i)Currency[:\s\S]{0,60}?([A-Z]{3})\b', blk)
    if not m_cur:
        m_cur = re.search(r'\b([A-Z]{3})\b', blk)
    if m_cur:
        res['devise'] = m_cur.group(1)

    # amount search: prefer labeled "Amount:", then generic money pattern
    m_amt = re.search(r'(?i)Amount[:\s\S]{0,80}?([\d]{1,3}(?:[.,]\d{3})*(?:[.,]\d{2})?)', blk)
    if not m_amt:
        m_amt = re.search(r'([\d]{1,3}(?:[.,]\d{3})*(?:[.,]\d{2}))', blk)
    if m_amt:
        res['montant'] = parse_amount(m_amt.group(1))
    return res

def extract_receiver_bic(text):
    # 1) chercher la zone "Receiver" et prendre le premier BIC dans son voisinage
    m = re.search(r'(?i)Receiver\s*[:\-]?\s*(.*?)(?=\n[A-Z][a-z]|$)', text, re.S)
    if m:
        part = m.group(1)
        m2 = BIC_RE.search(part)
        if m2:
            return m2.group(0)
    # 2) fallback: chercher la premiÃ¨re occurrence "Receiver" puis BIC dans 0..200 chars
    idx = text.upper().find('RECEIVER')
    if idx >= 0:
        tail = text[idx: idx + 300]
        m2 = BIC_RE.search(tail)
        if m2:
            return m2.group(0)
    # 3) fallback global: prefer first BIC after "Swift Input" or after "Sender"/"Receiver"
    m_any = BIC_RE.findall(text)
    return m_any[0] if m_any else None

def parse_f52a_name(text):
    blk = get_field_block(text, 'F52A')
    if not blk:
        # try simple fallback: search for ORABANK-like lines
        m = re.search(r'(?mi)([A-Z][A-Z0-9\ \-]{4,60}GABON|ORABANK\s+[A-Z]+)', text)
        if m: return m.group(0).strip()
        return None
    lines = [l.strip() for l in blk.splitlines() if l.strip()]
    name_lines = []
    for ln in lines:
        up = ln.upper()
        # skip labels
        if up.startswith('IDENTIFIER') or up.startswith('IDENTIFIERCODE') or up.startswith('CODE') or up.startswith('PARTYIDENTIFIER') or up.startswith('IDENTIFIANT'):
            continue
        # skip pure account or slash codes
        if re.match(r'^\/[A-Z0-9\/]+', ln): continue
        # skip lines that are pure BIC-like
        if re.fullmatch(r'[A-Z]{6,11}', ln.replace(' ', '')): continue
        # skip lines that are clearly "Address" tokens like "FRANKFURT AM MAIN DE" if they follow name we may keep city though
        # Collect likely name lines (containing letters and length > 3)
        if re.search(r'[A-Za-z]{2,}', ln) and len(ln) > 2:
            name_lines.append(ln)
    if not name_lines:
        return None
    # heuristique : prefer the line that contains 'BANK' or the longest line among first two
    for ln in name_lines:
        if 'BANK' in ln.upper() or 'BANQUE' in ln.upper():
            # return this plus next line if next looks like country/city
            i = name_lines.index(ln)
            out = ln
            if i+1 < len(name_lines) and len(name_lines[i+1]) < 30:
                out = f"{out} {name_lines[i+1]}"
            return out.strip()
    # otherwise return the first two good lines joined
    return ' '.join(name_lines[:2]).strip()

# ---------- main extractor ----------
def extract_for_mt202(pdf_path):
    txt = extract_text_from_pdf(pdf_path)
    row = {
        "code_banque": None,
        "date_reference": None,
        "reference": None,
        "type_MT": None,
        "pays_iso3": None,
        "institution_name": None,
        "montant": None,
        "devise": None,
        "source_pdf": getattr(pdf_path, "name", str(pdf_path))
    }

    # code banque: prefer receiver BIC
    rb = extract_receiver_bic(txt)
    row["code_banque"] = rb

    # type MT
    m = MT_RE.search(txt)
    if m:
        row["type_MT"] = f"fin.{m.group(1)}".lower()

    # reference: robust parse
    row["reference"] = parse_reference(txt)

    # F32A
    f32 = parse_f32a(txt)
    row["date_reference"] = f32.get("date_reference")
    row["devise"] = f32.get("devise")
    row["montant"] = f32.get("montant")

    # F52A institution name
    row["institution_name"] = parse_f52a_name(txt)

    # country
    row["pays_iso3"] = detect_country_from_text(txt)

    return row
